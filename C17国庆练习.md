### 国庆练习
### 1 小凯的疑惑
###   1.1 题面
[按照惯例给出pdf](docs/2017.pdf)
###   1.2 题解
一道简单的树上DP，但是精度很高，而且不能在DP过程中取mo，怎么办？尝试着先得出决策，后计算答案。有一个套路：化相乘为相加，即对每一个权值取$log$。更形式化的：
$$若 a^x * a^y > a^z \\ \therefore a^{x + y} > a^z \\
x + y > z$$

### 2 时间复杂度
###   2.1 题面
貌似就是上面的那一个PDF。
###   2.2 题解
（来自 lqs 的神仙做法）
观察到b是具有单调性的，如果一个数字p导致一个区间不可行，那么这个区间所有包含p的子区间
必然也不可行。
考虑分治,f(l,r)表示当前分治到l,r，那么我们把[l,r]中所有出现次数$<b_{r - l + 1}$的数字全部删
掉，区间就变成了若干段，分别递归处理即可。如果当前区间没有删掉任何数字，那么说明当前区间就
是合法的，直接更新答案。
考虑这个做法的复杂度，即考虑递归层数。不难发现当删除数字的时候递归层数才会增加，而最多有$\sqrt{n}$
种不同的出现次数，因此这个做法的复杂度为 $O(\sqrt{n})$。
优化分治做法。
首先一次找出所有出现次数较小的数字比较耗时，我们可以找到任意一个出现次数不满足要求的数字，
并且从这个数字处把区间分成两半进行递归，并不会影响正确性，还大大降低了编程复杂度。
但是由于分治两边可能不均等，会导致时间复杂度退化成 $O(n^2)$，但如果我们在$O(\log n)$的时间内完成当前层的操作，复杂度就是启发式合并的复杂度，即
$O(n \log n)$。
于是利用类似于 meet in the middle 的思想，我们从区间两端同时找出现次数不满足要求的数字，显然
寻找的时间就是min(左右两区间长度)了。但是我们还需要维护每个数字的出现次数，考虑记cnt
数组为每个数字的出现次数，并且假定每次递归时cnt数组恰好是当前区间中所有数字的出现次数，并
且返回时清空cnt数组。
把拆开的两区间中较大的称为大区间，较小的称为小区间，每次找到分割点后，先把小区间中所有数字
从cnt当中去掉，就可以直接递归大区间了。之后cnt数组被清空，我们只需要再遍历一遍小区间，
把所有数字加到cnt中，递归完毕后cnt也恰好被清空，符合返回要求。
特殊的，如果一个区间找不到分割点，则需要遍历整个区间清空cnt，复杂度显然没有问题。初始时，
必须设置为每个数字的出现次数再进行递归。
由于每一步花费的复杂度都是$O(小区间长度)$，因此总复杂度为$O(n \log n)$，可以通过。
其实来说，这道题目的解法仅仅只是利用了那个性质的暴力做法，并且使用启发式合并进行优化。**这是一种常见的套路。**

